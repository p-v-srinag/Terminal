<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>⚡ Web Terminal Dashboard</title>
<link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
<div id="terminal" tabindex="0"></div>

<script>
const terminal = document.getElementById("terminal");
let history = [];
let historyIndex = -1;
let currentCommand = "";
let cursorPos = 0;
let mode = "terminal"; // terminal | editor | game
let editorContent = "";
let currentFile = "";
let gameMenuIndex = 0;
const gameList = ["Snake", "Tetris", "2048"];
const commandsList = ["ls","cd","pwd","mkdir","rmdir","rm","touch","cat","echo","mv","cp","history","clear","sudo","pip install","python3","nano","vim","date","whoami","game"];

function newPrompt() {
  const line = document.createElement("div");
  line.classList.add("line");
  line.innerHTML = `<span class="prompt">$ </span><span class="command-input"><span class="current-command"></span><span class="cursor"></span></span><span class="suggestion-inline"></span>`;
  terminal.appendChild(line);
  cursorPos = 0;
  scrollTerminal();
}
function scrollTerminal() { terminal.scrollTop = terminal.scrollHeight; }

function renderCommand() {
    const line = document.querySelector(".line:last-child");
    if (!line) return;

    const cmdElem = line.querySelector(".current-command");
    const cursor = line.querySelector(".cursor");
    const suggestionElem = line.querySelector(".suggestion-inline");

    const left = currentCommand.slice(0, cursorPos);
    const right = currentCommand.slice(cursorPos);
    
    // Clear previous content and rebuild
    cmdElem.innerHTML = ''; 
    cmdElem.appendChild(document.createTextNode(left));
    cmdElem.appendChild(cursor);
    cmdElem.appendChild(document.createTextNode(right));

    // Inline suggestion logic
    if (currentCommand && cursorPos === currentCommand.length) {
        const suggestion = commandsList.find(c => c.startsWith(currentCommand.toLowerCase()) && c.length > currentCommand.length);
        if (suggestion) {
            suggestionElem.textContent = suggestion.slice(currentCommand.length);
        } else {
            suggestionElem.textContent = "";
        }
    } else {
        suggestionElem.textContent = "";
    }
}


// Fake local executor
async function executeCommand(cmd) {
    const line = document.querySelector(".line:last-child");
    if (line) {
        const commandInput = line.querySelector(".command-input");
        if(commandInput) {
             commandInput.remove();
        }
        const suggestionElem = line.querySelector(".suggestion-inline");
        if(suggestionElem) suggestionElem.remove();
        line.insertAdjacentHTML('beforeend', `<span class="current-command">${cmd}</span>`);
    }


  let output = "";
  if (cmd.trim() && cmd.toLowerCase() !== 'history') history.push(cmd);
  historyIndex = history.length;

  if (cmd === "clear") {
    terminal.innerHTML = "";
    newPrompt();
    currentCommand = "";
    return;
  }
  else if (cmd === "history") {
    output = history.slice(0, -1).join("\n");
  }
  else if (cmd === "date") {
    output = new Date().toString();
  }
  else if (cmd === "whoami") {
    output = "guest@web-terminal";
  }
  else if (cmd.startsWith("nano") || cmd.startsWith("vim")) {
    const parts = cmd.split(" ");
    if (parts.length > 1) {
        currentFile = parts[1];
        const res = await fetch("/run", {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({command: cmd})
        });
        const data = await res.json();
        editorContent = data.output;
        startEditor();
    } else {
        output = `Usage: ${parts[0]} <filename>`;
    }
    if (output) {
        const outDiv = document.createElement("div");
        outDiv.textContent = output;
        terminal.appendChild(outDiv);
        newPrompt();
    }
    currentCommand = "";
    return;

  }
  else if (cmd === "game") {
    startGameMenu();
    currentCommand = "";
    return;
  }
  else {
    // backend
    const res = await fetch("/run", {
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body: JSON.stringify({command:cmd})
    });
    const data = await res.json();
    output = data.output;
  }

  if (output) {
    const outDiv = document.createElement("div");
    outDiv.textContent = output;
    terminal.appendChild(outDiv);
  }
  newPrompt();
  currentCommand = "";
}

// Editor mode
function startEditor() {
    mode = "editor";
    const editor = document.createElement("textarea");
    editor.className = "editor";
    editor.value = editorContent;
    terminal.appendChild(editor);
    editor.focus();
    scrollTerminal();
}
async function exitEditor() {
    mode = "terminal";
    const editor = document.querySelector(".editor");
    editorContent = editor.value;
    const res = await fetch("/save", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({filename: currentFile, content: editorContent})
    });
    const data = await res.json();
    
    editor.remove(); // Remove editor before adding message
    const saveMsg = document.createElement("div");
    saveMsg.textContent = data.output;
    terminal.appendChild(saveMsg);
    
    currentCommand = ""; // Clear command after exit
    newPrompt();
}


// Game menu
function startGameMenu() {
  mode = "game";
  const gameDiv = document.createElement("div");
  gameDiv.className = "game-area";
  gameDiv.id = "gameMenu";
  terminal.appendChild(gameDiv);
  renderGameMenu();
  scrollTerminal();
}
function renderGameMenu() {
    const gameMenu = document.getElementById("gameMenu");
    if (!gameMenu) return;
    gameMenu.innerHTML = "Select a game:\n" + gameList.map((game, index) => {
        return `  ${index === gameMenuIndex ? '>>' : '  '} ${game}`;
    }).join("\n");
}
function exitGame(message) {
    const gameArea = document.querySelector(".game-area");
    if(gameArea) gameArea.remove();

    const msgDiv = document.createElement("div");
    msgDiv.textContent = message;
    terminal.appendChild(msgDiv);

    mode = "terminal";
    newPrompt();
}
function startSnake() {
    exitGame("[ Snake game placeholder 🐍. Press any key to exit. ]");
}


/* KEY HANDLING */
terminal.addEventListener("keydown", async (e)=>{
  if (mode==="editor") {
    if (e.key==="Escape" || (e.ctrlKey && e.key==="s")) {
        e.preventDefault();
        await exitEditor();
    }
    return;
  }
  if (mode==="game") {
    e.preventDefault();
    if (e.key==="ArrowUp" && gameMenuIndex > 0) {
        gameMenuIndex--;
        renderGameMenu();
    } else if (e.key==="ArrowDown" && gameMenuIndex < gameList.length - 1) {
        gameMenuIndex++;
        renderGameMenu();
    } else if (e.key === "Enter") {
        switch(gameMenuIndex) {
            case 0: // Snake
                startSnake();
                break;
            default:
                exitGame(`[ ${gameList[gameMenuIndex]} is not implemented yet. ]`);
                break;
        }
    } else if (e.key === "Escape") {
        exitGame("[ Exited game menu. ]");
    }
    return;
  }

  e.preventDefault();
  const suggestionText = document.querySelector(".suggestion-inline")?.textContent || "";
  if(e.key.length===1){
    currentCommand = currentCommand.slice(0,cursorPos)+e.key+currentCommand.slice(cursorPos);
    cursorPos++;
  }
  else if(e.key==="Backspace" && cursorPos>0){
    currentCommand = currentCommand.slice(0,cursorPos-1)+currentCommand.slice(cursorPos);
    cursorPos--;
  }
  else if(e.key==="ArrowLeft" && cursorPos>0){ cursorPos--; }
  else if(e.key==="ArrowRight"){ 
      if (cursorPos < currentCommand.length) {
          cursorPos++;
      } else if (suggestionText) {
          // Accept suggestion with right arrow at the end
          currentCommand += suggestionText;
          cursorPos = currentCommand.length;
      }
  }
  else if (e.key === "Tab") {
        if (suggestionText) {
            currentCommand += suggestionText;
            cursorPos = currentCommand.length;
        }
  }
  else if(e.key==="Enter"){ await executeCommand(currentCommand); }
  else if(e.key==="ArrowUp"){ if(historyIndex>0){ historyIndex--; currentCommand=history[historyIndex-1] || ""; cursorPos=currentCommand.length; } }
  else if(e.key==="ArrowDown"){ if(historyIndex<history.length){ historyIndex++; currentCommand=history[historyIndex] || ""; cursorPos=currentCommand.length; } else { currentCommand=""; cursorPos=0; } }

  renderCommand();
});

newPrompt();
currentCommand = "";
terminal.focus();
terminal.addEventListener("click",()=>terminal.focus());
</script>
</body>
</html>